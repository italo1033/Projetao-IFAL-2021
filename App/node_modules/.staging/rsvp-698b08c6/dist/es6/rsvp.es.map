{"version":3,"sources":["config/versionTemplate.txt","../../../../../../../../../../../../../../../../../lib/rsvp/events.js","../../../../../../../../../../../../../../../../../lib/rsvp/config.js","../../../../../../../../../../../../../../../../../lib/rsvp/instrument.js","../../../../../../../../../../../../../../../../../lib/rsvp/promise/resolve.js","../../../../../../../../../../../../../../../../../lib/rsvp/-internal.js","../../../../../../../../../../../../../../../../../lib/rsvp/then.js","../../../../../../../../../../../../../../../../../lib/rsvp/enumerator.js","../../../../../../../../../../../../../../../../../lib/rsvp/promise/all.js","../../../../../../../../../../../../../../../../../lib/rsvp/promise/race.js","../../../../../../../../../../../../../../../../../lib/rsvp/promise/reject.js","../../../../../../../../../../../../../../../../../lib/rsvp/promise.js","../../../../../../../../../../../../../../../../../lib/rsvp/node.js","../../../../../../../../../../../../../../../../../lib/rsvp/all.js","../../../../../../../../../../../../../../../../../lib/rsvp/all-settled.js","../../../../../../../../../../../../../../../../../lib/rsvp/race.js","../../../../../../../../../../../../../../../../../lib/rsvp/promise-hash.js","../../../../../../../../../../../../../../../../../lib/rsvp/hash.js","../../../../../../../../../../../../../../../../../lib/rsvp/hash-settled.js","../../../../../../../../../../../../../../../../../lib/rsvp/rethrow.js","../../../../../../../../../../../../../../../../../lib/rsvp/defer.js","../../../../../../../../../../../../../../../../../lib/rsvp/map.js","../../../../../../../../../../../../../../../../../lib/rsvp/resolve.js","../../../../../../../../../../../../../../../../../lib/rsvp/reject.js","../../../../../../../../../../../../../../../../../lib/rsvp/filter.js","../../../../../../../../../../../../../../../../../lib/rsvp/asap.js","../../../../../../../../../../../../../../../../../lib/rsvp.js"],"sourcesContent":["/*!\n * @overview RSVP - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2016 Yehuda Katz, Tom Dale, Stefan Penner and contributors\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE\n * @version   4.8.4+ff10049b\n */\n","\nfunction callbacksFor(object) {\n  let callbacks = object._promiseCallbacks;\n\n  if (!callbacks) {\n    callbacks = object._promiseCallbacks = {};\n  }\n\n  return callbacks;\n}\n\n/**\n  @class EventTarget\n  @for rsvp\n  @public\n*/\nexport default {\n\n  /**\n    `EventTarget.mixin` extends an object with EventTarget methods. For\n    Example:\n\n    ```javascript\n    import EventTarget from 'rsvp';\n\n    let object = {};\n\n    EventTarget.mixin(object);\n\n    object.on('finished', function(event) {\n      // handle event\n    });\n\n    object.trigger('finished', { detail: value });\n    ```\n\n    `EventTarget.mixin` also works with prototypes:\n\n    ```javascript\n    import EventTarget from 'rsvp';\n\n    let Person = function() {};\n    EventTarget.mixin(Person.prototype);\n\n    let yehuda = new Person();\n    let tom = new Person();\n\n    yehuda.on('poke', function(event) {\n      console.log('Yehuda says OW');\n    });\n\n    tom.on('poke', function(event) {\n      console.log('Tom says OW');\n    });\n\n    yehuda.trigger('poke');\n    tom.trigger('poke');\n    ```\n\n    @method mixin\n    @for rsvp\n    @private\n    @param {Object} object object to extend with EventTarget methods\n  */\n  mixin(object) {\n    object.on      = this.on;\n    object.off     = this.off;\n    object.trigger = this.trigger;\n    object._promiseCallbacks = undefined;\n    return object;\n  },\n\n  /**\n    Registers a callback to be executed when `eventName` is triggered\n\n    ```javascript\n    object.on('event', function(eventInfo){\n      // handle the event\n    });\n\n    object.trigger('event');\n    ```\n\n    @method on\n    @for EventTarget\n    @private\n    @param {String} eventName name of the event to listen for\n    @param {Function} callback function to be called when the event is triggered.\n  */\n  on(eventName, callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback must be a function');\n    }\n\n    let allCallbacks = callbacksFor(this);\n    let callbacks = allCallbacks[eventName];\n\n    if (!callbacks) {\n      callbacks = allCallbacks[eventName] = [];\n    }\n\n    if (callbacks.indexOf(callback) === -1) {\n      callbacks.push(callback);\n    }\n  },\n\n  /**\n    You can use `off` to stop firing a particular callback for an event:\n\n    ```javascript\n    function doStuff() { // do stuff! }\n    object.on('stuff', doStuff);\n\n    object.trigger('stuff'); // doStuff will be called\n\n    // Unregister ONLY the doStuff callback\n    object.off('stuff', doStuff);\n    object.trigger('stuff'); // doStuff will NOT be called\n    ```\n\n    If you don't pass a `callback` argument to `off`, ALL callbacks for the\n    event will not be executed when the event fires. For example:\n\n    ```javascript\n    let callback1 = function(){};\n    let callback2 = function(){};\n\n    object.on('stuff', callback1);\n    object.on('stuff', callback2);\n\n    object.trigger('stuff'); // callback1 and callback2 will be executed.\n\n    object.off('stuff');\n    object.trigger('stuff'); // callback1 and callback2 will not be executed!\n    ```\n\n    @method off\n    @for rsvp\n    @private\n    @param {String} eventName event to stop listening to\n    @param {Function} [callback] optional argument. If given, only the function\n    given will be removed from the event's callback queue. If no `callback`\n    argument is given, all callbacks will be removed from the event's callback\n    queue.\n  */\n  off(eventName, callback) {\n    let allCallbacks = callbacksFor(this);\n\n    if (!callback) {\n      allCallbacks[eventName] = [];\n      return;\n    }\n\n    let callbacks = allCallbacks[eventName];\n    let index = callbacks.indexOf(callback);\n\n    if (index !== -1) {\n      callbacks.splice(index, 1);\n    }\n  },\n\n  /**\n    Use `trigger` to fire custom events. For example:\n\n    ```javascript\n    object.on('foo', function(){\n      console.log('foo event happened!');\n    });\n    object.trigger('foo');\n    // 'foo event happened!' logged to the console\n    ```\n\n    You can also pass a value as a second argument to `trigger` that will be\n    passed as an argument to all event listeners for the event:\n\n    ```javascript\n    object.on('foo', function(value){\n      console.log(value.name);\n    });\n\n    object.trigger('foo', { name: 'bar' });\n    // 'bar' logged to the console\n    ```\n\n    @method trigger\n    @for rsvp\n    @private\n    @param {String} eventName name of the event to be triggered\n    @param {*} [options] optional value to be passed to any event handlers for\n    the given `eventName`\n  */\n  trigger(eventName, options, label) {\n    let allCallbacks = callbacksFor(this);\n\n    let callbacks = allCallbacks[eventName];\n    if (callbacks) {\n      // Don't cache the callbacks.length since it may grow\n      let callback;\n      for (let i = 0; i < callbacks.length; i++) {\n        callback = callbacks[i];\n        callback(options, label);\n      }\n    }\n  }\n};\n","import EventTarget from './events';\n\nconst config = {\n  instrument: false\n};\n\nEventTarget['mixin'](config);\n\nfunction configure(name, value) {\n  if (arguments.length === 2) {\n    config[name] = value;\n  } else {\n    return config[name];\n  }\n}\n\nexport {\n  config,\n  configure\n};\n","import { config } from './config';\n\nconst queue = [];\n\nfunction scheduleFlush() {\n  setTimeout(() => {\n    for (let i = 0; i < queue.length; i++) {\n      let entry = queue[i];\n\n      let payload = entry.payload;\n\n      payload.guid = payload.key + payload.id;\n      payload.childGuid = payload.key + payload.childId;\n      if (payload.error) {\n        payload.stack = payload.error.stack;\n      }\n\n      config['trigger'](entry.name, entry.payload);\n    }\n    queue.length = 0;\n  }, 50);\n}\n\nexport default function instrument(eventName, promise, child) {\n  if (1 === queue.push({\n    name: eventName,\n    payload: {\n      key: promise._guidKey,\n      id:  promise._id,\n      eventName: eventName,\n      detail: promise._result,\n      childId: child && child._id,\n      label: promise._label,\n      timeStamp: Date.now(),\n      error: config[\"instrument-with-stack\"] ? new Error(promise._label) : null\n    }})) {\n      scheduleFlush();\n    }\n  }\n","import {\n  noop,\n  resolve as _resolve\n} from '../-internal';\n\n/**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  import Promise from 'rsvp';\n\n  let promise = RSVP.Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @for Promise\n  @static\n  @param {*} object value that the returned promise will be resolved with\n  @param {String} [label] optional string for identifying the returned promise.\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/\nexport default function resolve(object, label) {\n  /*jshint validthis:true */\n  let Constructor = this;\n\n  if (object && typeof object === 'object' && object.constructor === Constructor) {\n    return object;\n  }\n\n  let promise = new Constructor(noop, label);\n  _resolve(promise, object);\n  return promise;\n}\n","import originalThen from './then';\nimport originalResolve from './promise/resolve';\nimport instrument from './instrument';\n\nimport { config } from './config';\nimport Promise from './promise';\n\nfunction withOwnPromise() {\n  return new TypeError('A promises callback cannot return that same promise.');\n}\n\nfunction objectOrFunction(x) {\n  let type = typeof x;\n  return x !== null && (type === 'object' || type === 'function');\n}\n\nexport function noop() {}\n\nexport const PENDING   = void 0;\nexport const FULFILLED = 1;\nexport const REJECTED  = 2;\n\nexport const TRY_CATCH_ERROR = { error: null };\n\nexport function getThen(promise) {\n  try {\n    return promise.then;\n  } catch(error) {\n    TRY_CATCH_ERROR.error = error;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nlet tryCatchCallback;\nfunction tryCatcher() {\n  try {\n    let target = tryCatchCallback;\n    tryCatchCallback = null;\n    return target.apply(this, arguments);\n  } catch(e) {\n    TRY_CATCH_ERROR.error = e;\n    return TRY_CATCH_ERROR;\n  }\n}\n\nexport function tryCatch(fn) {\n  tryCatchCallback = fn;\n  return tryCatcher;\n}\n\nfunction handleForeignThenable(promise, thenable, then) {\n  config.async(promise => {\n    let sealed = false;\n    let result = tryCatch(then).call(\n      thenable,\n      value => {\n        if (sealed) { return; }\n        sealed = true;\n        if (thenable === value) {\n          fulfill(promise, value);\n        } else {\n          resolve(promise, value);\n        }\n      },\n      reason => {\n        if (sealed) { return; }\n        sealed = true;\n\n        reject(promise, reason);\n      },\n      'Settle: ' + (promise._label || ' unknown promise')\n    );\n\n    if (!sealed && result === TRY_CATCH_ERROR) {\n      sealed = true;\n      let error = TRY_CATCH_ERROR.error;\n      TRY_CATCH_ERROR.error = null;\n      reject(promise, error);\n    }\n\n  }, promise);\n}\n\nfunction handleOwnThenable(promise, thenable) {\n  if (thenable._state === FULFILLED) {\n    fulfill(promise, thenable._result);\n  } else if (thenable._state === REJECTED) {\n    thenable._onError = null;\n    reject(promise, thenable._result);\n  } else {\n    subscribe(thenable, undefined, value => {\n      if (thenable === value) {\n        fulfill(promise, value);\n      } else {\n        resolve(promise, value);\n      }\n    }, reason => reject(promise, reason));\n  }\n}\n\nexport function handleMaybeThenable(promise, maybeThenable, then) {\n  let isOwnThenable =\n    maybeThenable.constructor === promise.constructor &&\n    then === originalThen &&\n    promise.constructor.resolve === originalResolve;\n\n  if (isOwnThenable) {\n    handleOwnThenable(promise, maybeThenable);\n  } else if (then === TRY_CATCH_ERROR) {\n    let error = TRY_CATCH_ERROR.error\n    TRY_CATCH_ERROR.error = null;\n    reject(promise, error);\n  } else if (typeof then === 'function') {\n    handleForeignThenable(promise, maybeThenable, then);\n  } else {\n    fulfill(promise, maybeThenable);\n  }\n}\n\nexport function resolve(promise, value) {\n  if (promise === value) {\n    fulfill(promise, value);\n  } else if (objectOrFunction(value)) {\n    handleMaybeThenable(promise, value, getThen(value));\n  } else {\n    fulfill(promise, value);\n  }\n}\n\nexport function publishRejection(promise) {\n  if (promise._onError) {\n    promise._onError(promise._result);\n  }\n\n  publish(promise);\n}\n\nexport function fulfill(promise, value) {\n  if (promise._state !== PENDING) { return; }\n\n  promise._result = value;\n  promise._state = FULFILLED;\n\n  if (promise._subscribers.length === 0) {\n    if (config.instrument) {\n      instrument('fulfilled', promise);\n    }\n  } else {\n    config.async(publish, promise);\n  }\n}\n\nexport function reject(promise, reason) {\n  if (promise._state !== PENDING) { return; }\n  promise._state = REJECTED;\n  promise._result = reason;\n  config.async(publishRejection, promise);\n}\n\nexport function subscribe(parent, child, onFulfillment, onRejection) {\n  let subscribers = parent._subscribers;\n  let length = subscribers.length;\n\n  parent._onError = null;\n\n  subscribers[length] = child;\n  subscribers[length + FULFILLED] = onFulfillment;\n  subscribers[length + REJECTED]  = onRejection;\n\n  if (length === 0 && parent._state) {\n    config.async(publish, parent);\n  }\n}\n\nexport function publish(promise) {\n  let subscribers = promise._subscribers;\n  let settled = promise._state;\n\n  if (config.instrument) {\n    instrument(settled === FULFILLED ? 'fulfilled' : 'rejected', promise);\n  }\n\n  if (subscribers.length === 0) { return; }\n\n  let child, callback, result = promise._result;\n\n  for (let i = 0; i < subscribers.length; i += 3) {\n    child = subscribers[i];\n    callback = subscribers[i + settled];\n\n    if (child) {\n      invokeCallback(settled, child, callback, result);\n    } else {\n      callback(result);\n    }\n  }\n\n  promise._subscribers.length = 0;\n}\n\nexport function invokeCallback(state, promise, callback, result) {\n  let hasCallback = typeof callback === 'function';\n  let value;\n\n  if (hasCallback) {\n    value = tryCatch(callback)(result);\n  } else {\n    value = result;\n  }\n\n  if (promise._state !== PENDING) {\n    // noop\n  } else if (value === promise) {\n    reject(promise, withOwnPromise());\n  } else if (value === TRY_CATCH_ERROR) {\n    let error = TRY_CATCH_ERROR.error;\n    TRY_CATCH_ERROR.error = null; // release\n    reject(promise, error);\n  } else if (hasCallback) {\n    resolve(promise, value);\n  } else if (state === FULFILLED) {\n    fulfill(promise, value);\n  } else if (state === REJECTED) {\n    reject(promise, value);\n  }\n}\n\nexport function initializePromise(promise, resolver) {\n  let resolved = false;\n  try {\n    resolver(value => {\n      if (resolved) { return; }\n      resolved = true;\n      resolve(promise, value);\n    }, reason => {\n      if (resolved) { return; }\n      resolved = true;\n      reject(promise, reason);\n    });\n  } catch(e) {\n    reject(promise, e);\n  }\n}\n","import { config } from './config';\nimport instrument from './instrument';\nimport {\n  noop,\n  subscribe,\n  FULFILLED,\n  REJECTED,\n  PENDING,\n  invokeCallback\n} from './-internal';\n\nexport default function then(onFulfillment, onRejection, label) {\n  let parent = this;\n  let state = parent._state;\n\n  if (state === FULFILLED && !onFulfillment || state === REJECTED && !onRejection) {\n    config.instrument && instrument('chained', parent, parent);\n    return parent;\n  }\n\n  parent._onError = null;\n\n  let child = new parent.constructor(noop, label);\n  let result = parent._result;\n\n  config.instrument && instrument('chained', parent, child);\n\n  if (state === PENDING) {\n    subscribe(parent, child, onFulfillment, onRejection);\n  } else {\n    let callback = state === FULFILLED ? onFulfillment : onRejection;\n    config.async(() => invokeCallback(state, child, callback, result));\n  }\n\n  return child;\n}\n","import {\n  noop,\n  resolve,\n  handleMaybeThenable,\n  reject,\n  fulfill,\n  subscribe,\n  FULFILLED,\n  REJECTED,\n  PENDING,\n  getThen\n} from './-internal';\n\nimport { default as OwnPromise } from './promise';\nimport ownThen from './then';\nimport ownResolve from './promise/resolve';\n\nexport default class Enumerator {\n  constructor(Constructor, input, abortOnReject, label) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop, label);\n    this._abortOnReject = abortOnReject;\n    this._isUsingOwnPromise = Constructor === OwnPromise;\n    this._isUsingOwnResolve = Constructor.resolve === ownResolve;\n\n    this._init(...arguments);\n  }\n\n  _init(Constructor, input) {\n    let len = input.length || 0;\n    this.length     = len;\n    this._remaining = len;\n    this._result = new Array(len);\n\n    this._enumerate(input);\n  }\n\n  _enumerate(input) {\n    let length  = this.length;\n    let promise = this.promise;\n\n    for (let i = 0; promise._state === PENDING && i < length; i++) {\n      this._eachEntry(input[i], i, true);\n    }\n    this._checkFullfillment();\n  }\n\n  _checkFullfillment() {\n    if (this._remaining === 0) {\n      let result = this._result;\n      fulfill(this.promise, result);\n      this._result = null\n    }\n  }\n\n  _settleMaybeThenable(entry, i, firstPass) {\n    let c = this._instanceConstructor;\n\n    if (this._isUsingOwnResolve) {\n      let then = getThen(entry);\n\n      if (then === ownThen && entry._state !== PENDING) {\n        entry._onError = null;\n        this._settledAt(entry._state, i, entry._result, firstPass);\n      } else if (typeof then !== 'function') {\n        this._settledAt(FULFILLED, i, entry, firstPass);\n      } else if (this._isUsingOwnPromise) {\n        let promise = new c(noop);\n        handleMaybeThenable(promise, entry, then);\n        this._willSettleAt(promise, i, firstPass);\n      } else {\n        this._willSettleAt(new c(resolve => resolve(entry)), i, firstPass);\n      }\n    } else {\n      this._willSettleAt(c.resolve(entry), i, firstPass);\n    }\n  }\n\n  _eachEntry(entry, i, firstPass) {\n    if (entry !== null && typeof entry === 'object') {\n      this._settleMaybeThenable(entry, i, firstPass);\n    } else {\n      this._setResultAt(FULFILLED, i, entry, firstPass);\n    }\n  }\n\n  _settledAt(state, i, value, firstPass) {\n    let promise = this.promise;\n\n    if (promise._state === PENDING) {\n      if (this._abortOnReject && state === REJECTED) {\n        reject(